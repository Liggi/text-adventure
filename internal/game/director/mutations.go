package director

import (
	"context"
	"encoding/json"
	"fmt"
	"log"
	"strings"

	tea "github.com/charmbracelet/bubbletea"
	"github.com/sashabaranov/go-openai"

	"textadventure/internal/game"
	"textadventure/internal/game/sensory"
	"textadventure/internal/logging"
	"textadventure/internal/mcp"
)

// MutationRequest represents a single world mutation to be executed
type MutationRequest struct {
	Tool string                 `json:"tool"`
	Args map[string]interface{} `json:"args"`
}

// MutationResponse contains the mutations generated by the LLM
type MutationResponse struct {
	Mutations []MutationRequest `json:"mutations"`
}

type MutationsGeneratedMsg struct {
	Mutations     []string
	Successes     []string
	Failures      []string
	SensoryEvents *sensory.SensoryEventResponse
	NewWorld      game.WorldState
	UserInput     string
	Debug         bool
	ActingNPCID   string
}

// GenerateMutations generates world mutations based on user input using the LLM Director
func GenerateMutations(client *openai.Client, userInput string, world game.WorldState, gameHistory []string, mcpClient *mcp.WorldStateClient, debug bool, actingNPCID string) (*MutationResponse, error) {
	toolDescriptions := `Available tools:
- get_world_state: Get current world state
- move_player: Move player to a different location {"location": "location_name"}
- transfer_item: Move item between locations/inventories {"item": "item_name", "from_location": "source", "to_location": "destination"}
- add_to_inventory: Add item to player inventory {"item": "item_name"}
- remove_from_inventory: Remove item from player inventory {"item": "item_name"}
- unlock_door: Unlock a door between locations {"from_location": "source", "to_location": "destination"}`

	var actionLabel string
	if actingNPCID != "" {
		actionLabel = fmt.Sprintf("NPC %s ACTION", strings.ToUpper(actingNPCID))
	} else {
		actionLabel = "Player action"
	}

	systemPrompt := fmt.Sprintf(`You are the Director of a text adventure game. Your role is to understand player intent and generate the specific world mutations needed to make it happen.

%s

WORLD STATE CONTEXT:
%s

RULES:
- Parse the %s and decide what world mutations are needed
- Generate JSON array of mutations using the available tools
- Be conservative - only generate mutations that directly relate to the stated action
- For movement: use move_player tool
- For picking up items: use transfer_item to move from location to player, then add_to_inventory
- For dropping items: use remove_from_inventory, then transfer_item to move to current location
- For examining/looking: usually no mutations needed
- NPCs can only affect items at their current location or their own movement

Return JSON format:
{
  "mutations": [
    {"tool": "move_player", "args": {"location": "kitchen"}},
    {"tool": "transfer_item", "args": {"item": "key", "from_location": "foyer", "to_location": "player"}}
  ]
}

If no mutations needed, return empty mutations array.`, toolDescriptions, buildWorldContext(world, gameHistory, actingNPCID), actionLabel)

	req := openai.ChatCompletionRequest{
		Model: "gpt-5-2025-08-07",
		Messages: []openai.ChatCompletionMessage{
			{
				Role:    openai.ChatMessageRoleSystem,
				Content: systemPrompt,
			},
			{
				Role:    openai.ChatMessageRoleUser,
				Content: fmt.Sprintf("%s: %s", actionLabel, userInput),
			},
		},
		MaxCompletionTokens: 400,
		ReasoningEffort:     "minimal",
		ResponseFormat: &openai.ChatCompletionResponseFormat{
			Type: openai.ChatCompletionResponseFormatTypeJSONObject,
		},
	}

	if debug {
		log.Printf("=== MUTATION GENERATION START ===")
		log.Printf("Action: %q", userInput)
		log.Printf("System prompt length: %d chars", len(systemPrompt))
	}

	resp, err := client.CreateChatCompletion(context.Background(), req)
	if err != nil {
		if debug {
			log.Printf("Mutation generation API error: %v", err)
		}
		return nil, fmt.Errorf("mutation generation failed: %w", err)
	}

	if debug {
		log.Printf("API Response - Choices length: %d", len(resp.Choices))
		if len(resp.Choices) > 0 {
			log.Printf("Response choice 0 - Content: %q", resp.Choices[0].Message.Content)
		}
	}

	var mutationResp MutationResponse
	content := resp.Choices[0].Message.Content
	
	if err := json.Unmarshal([]byte(content), &mutationResp); err != nil {
		if debug {
			log.Printf("JSON unmarshal failed: %v", err)
			log.Printf("Content was: %q", content)
		}
		return &MutationResponse{Mutations: []MutationRequest{}}, nil
	}

	if debug {
		log.Printf("Generated %d mutations", len(mutationResp.Mutations))
		for i, mutation := range mutationResp.Mutations {
			log.Printf("  Mutation %d: %s with args %v", i, mutation.Tool, mutation.Args)
		}
		log.Printf("=== MUTATION GENERATION END ===")
	}

	return &mutationResp, nil
}

// ExecuteMutations executes a list of mutations using the MCP client
func ExecuteMutations(ctx context.Context, mutations []MutationRequest, mcpClient *mcp.WorldStateClient, debug bool, world game.WorldState, actingNPCID string) ([]string, []string) {
	var successes []string
	var failures []string
	
	for _, mutation := range mutations {
		if debug {
			log.Printf("Executing mutation: %s with args: %v", mutation.Tool, mutation.Args)
		}
		
		switch mutation.Tool {
		case "get_world_state":
			if debug {
				log.Printf("Getting world state...")
			}
			_, err := mcpClient.GetWorldState(ctx)
			if err != nil {
				failure := fmt.Sprintf("Failed to get world state: %v", err)
				failures = append(failures, failure)
				if debug {
					log.Printf("ERROR: %s", failure)
				}
			} else {
				success := "Retrieved world state"
				successes = append(successes, success)
				if debug {
					log.Printf("SUCCESS: %s", success)
				}
			}
			
		case "move_player":
			if location, ok := mutation.Args["location"].(string); ok {
				if debug {
					log.Printf("Moving player to: %s", location)
				}
				_, err := mcpClient.MovePlayer(ctx, location)
				if err != nil {
					failure := fmt.Sprintf("Failed to move to %s: %v", location, err)
					failures = append(failures, failure)
					if debug {
						log.Printf("ERROR: %s", failure)
					}
				} else {
					var successMsg string
					if actingNPCID != "" {
						successMsg = fmt.Sprintf("NPC %s moved to %s", actingNPCID, location)
					} else {
						successMsg = fmt.Sprintf("Moved to %s", location)
					}
					successes = append(successes, successMsg)
					if debug {
						log.Printf("SUCCESS: %s", successMsg)
					}
				}
			} else {
				failure := "move_player requires 'location' parameter"
				failures = append(failures, failure)
				if debug {
					log.Printf("ERROR: %s", failure)
				}
			}
			
		case "transfer_item":
			item, hasItem := mutation.Args["item"].(string)
			fromLoc, hasFrom := mutation.Args["from_location"].(string)
			toLoc, hasTo := mutation.Args["to_location"].(string)
			
			if hasItem && hasFrom && hasTo {
				if debug {
					log.Printf("Transferring %s from %s to %s", item, fromLoc, toLoc)
				}
				_, err := mcpClient.TransferItem(ctx, item, fromLoc, toLoc)
				if err != nil {
					failure := fmt.Sprintf("Failed to transfer %s from %s to %s: %v", item, fromLoc, toLoc, err)
					failures = append(failures, failure)
					if debug {
						log.Printf("ERROR: %s", failure)
					}
				} else {
					success := fmt.Sprintf("Transferred %s from %s to %s", item, fromLoc, toLoc)
					successes = append(successes, success)
					if debug {
						log.Printf("SUCCESS: %s", success)
					}
				}
			} else {
				failure := "transfer_item requires 'item', 'from_location', and 'to_location' parameters"
				failures = append(failures, failure)
				if debug {
					log.Printf("ERROR: %s", failure)
				}
			}
			
		case "add_to_inventory":
			if item, ok := mutation.Args["item"].(string); ok {
				if debug {
					log.Printf("Adding %s to inventory", item)
				}
				_, err := mcpClient.AddToInventory(ctx, item)
				if err != nil {
					failure := fmt.Sprintf("Failed to add %s to inventory: %v", item, err)
					failures = append(failures, failure)
					if debug {
						log.Printf("ERROR: %s", failure)
					}
				} else {
					success := fmt.Sprintf("Added %s to inventory", item)
					successes = append(successes, success)
					if debug {
						log.Printf("SUCCESS: %s", success)
					}
				}
			} else {
				failure := "add_to_inventory requires 'item' parameter"
				failures = append(failures, failure)
				if debug {
					log.Printf("ERROR: %s", failure)
				}
			}
			
		case "remove_from_inventory":
			if item, ok := mutation.Args["item"].(string); ok {
				if debug {
					log.Printf("Removing %s from inventory", item)
				}
				_, err := mcpClient.RemoveFromInventory(ctx, item)
				if err != nil {
					failure := fmt.Sprintf("Failed to remove %s from inventory: %v", item, err)
					failures = append(failures, failure)
					if debug {
						log.Printf("ERROR: %s", failure)
					}
				} else {
					success := fmt.Sprintf("Removed %s from inventory", item)
					successes = append(successes, success)
					if debug {
						log.Printf("SUCCESS: %s", success)
					}
				}
			} else {
				failure := "remove_from_inventory requires 'item' parameter"
				failures = append(failures, failure)
				if debug {
					log.Printf("ERROR: %s", failure)
				}
			}
			
		case "unlock_door":
			fromLoc, hasFrom := mutation.Args["from_location"].(string)
			toLoc, hasTo := mutation.Args["to_location"].(string)
			
			if hasFrom && hasTo {
				if debug {
					log.Printf("Unlocking door from %s to %s", fromLoc, toLoc)
				}
				_, err := mcpClient.UnlockDoor(ctx, fromLoc, toLoc, "")
				if err != nil {
					failure := fmt.Sprintf("Failed to unlock door from %s to %s: %v", fromLoc, toLoc, err)
					failures = append(failures, failure)
					if debug {
						log.Printf("ERROR: %s", failure)
					}
				} else {
					success := fmt.Sprintf("Unlocked door from %s to %s", fromLoc, toLoc)
					successes = append(successes, success)
					if debug {
						log.Printf("SUCCESS: %s", success)
					}
				}
			} else {
				failure := "unlock_door requires 'from_location' and 'to_location' parameters"
				failures = append(failures, failure)
				if debug {
					log.Printf("ERROR: %s", failure)
				}
			}
			
		default:
			failure := fmt.Sprintf("Unknown tool: %s", mutation.Tool)
			failures = append(failures, failure)
			if debug {
				log.Printf("ERROR: %s", failure)
			}
		}
	}
	
	if debug {
		log.Printf("Mutation execution complete: %d successes, %d failures", len(successes), len(failures))
	}
	
	return successes, failures
}

// generateAndExecuteMutationsWithRetries generates mutations and executes them, with retry logic
func generateAndExecuteMutationsWithRetries(ctx context.Context, client *openai.Client, userInput string, world game.WorldState, gameHistory []string, mcpClient *mcp.WorldStateClient, debug bool, actingNPCID string) ([]string, []string, error) {
	mutationResp, err := GenerateMutations(client, userInput, world, gameHistory, mcpClient, debug, actingNPCID)
	if err != nil {
		return nil, nil, fmt.Errorf("failed to generate mutations: %w", err)
	}
	
	if len(mutationResp.Mutations) == 0 {
		return []string{}, []string{}, nil
	}
	
	pendingMutations := mutationResp.Mutations
	var allSuccesses []string
	var allFailures []string
	
	for attempt := 0; attempt < 2 && len(pendingMutations) > 0; attempt++ {
		if debug {
			log.Printf("Mutation attempt %d with %d mutations", attempt+1, len(pendingMutations))
		}
		
		successes, failures := ExecuteMutations(ctx, pendingMutations, mcpClient, debug, world, actingNPCID)
		allSuccesses = append(allSuccesses, successes...)
		
		if len(failures) == 0 {
			break
		}
		
		allFailures = append(allFailures, failures...)
		
		if attempt == 0 && len(failures) > 0 {
			retryPrompt := fmt.Sprintf("Previous attempt failed with errors: %s. Please try a different approach for: %s", 
				strings.Join(failures, "; "), userInput)
			
			retryResp, err := GenerateMutations(client, retryPrompt, world, gameHistory, mcpClient, debug, actingNPCID)
			if err != nil {
				if debug {
					log.Printf("Retry mutation generation failed: %v", err)
				}
				break
			}
			pendingMutations = retryResp.Mutations
		} else {
			break
		}
	}
	
	return allSuccesses, allFailures, nil
}

// StartTwoStepLLMFlow orchestrates the two-step flow: generate mutations → execute → create sensory events → narrate
func StartTwoStepLLMFlow(client *openai.Client, userInput string, world game.WorldState, gameHistory []string, logger *logging.CompletionLogger, mcpClient *mcp.WorldStateClient, debug bool, actingNPCID ...string) tea.Cmd {
	return func() tea.Msg {
		ctx := context.Background()
		
		var npcID string
		if len(actingNPCID) > 0 {
			npcID = actingNPCID[0]
		}
		
		successes, failures, err := generateAndExecuteMutationsWithRetries(ctx, client, userInput, world, gameHistory, mcpClient, debug, npcID)
		if err != nil {
			if debug {
				log.Printf("Mutation generation/execution failed: %v", err)
			}
			successes = []string{}
			failures = []string{fmt.Sprintf("Failed to process action: %v", err)}
		}
		
		mcpWorld, err := mcpClient.GetWorldState(ctx)
		var newWorld game.WorldState
		if err != nil {
			if debug {
				log.Printf("Failed to get updated world state: %v", err)
			}
			newWorld = world
		} else {
			newWorld = mcp.MCPToGameWorldState(mcpWorld)
		}
		
		sensoryEvents, err := sensory.GenerateSensoryEvents(client, userInput, successes, newWorld, debug, npcID)
		if err != nil {
			if debug {
				log.Printf("Failed to generate sensory events: %v", err)
			}
			sensoryEvents = &sensory.SensoryEventResponse{AuditoryEvents: []sensory.SensoryEvent{}}
		}
		
		var allMessages []string
		if debug {
			allMessages = append(allMessages, "[MUTATIONS]")
			if len(successes) > 0 {
				allMessages = append(allMessages, successes...)
			}
			if len(failures) > 0 {
				for _, failure := range failures {
					allMessages = append(allMessages, "[ERROR] "+failure)
				}
			}
			if len(successes) == 0 && len(failures) == 0 {
				allMessages = append(allMessages, "No mutations needed")
			}
		}
		
		return MutationsGeneratedMsg{
			Mutations:     allMessages,
			Successes:     successes,
			Failures:      failures,
			SensoryEvents: sensoryEvents,
			NewWorld:      newWorld,
			UserInput:     userInput,
			Debug:         debug,
			ActingNPCID:   npcID,
		}
	}
}

// buildWorldContext creates a context string for the LLM Director
func buildWorldContext(world game.WorldState, gameHistory []string, actingNPCID ...string) string {
	var context strings.Builder
	
	context.WriteString("WORLD STATE:\n")
	
	if len(actingNPCID) > 0 && actingNPCID[0] != "" {
		npcID := actingNPCID[0]
		if npc, exists := world.NPCs[npcID]; exists {
			currentLoc := world.Locations[npc.Location]
			context.WriteString(fmt.Sprintf("NPC %s Location: %s (%s)\n", npcID, currentLoc.Title, npc.Location))
			context.WriteString(currentLoc.Description + "\n")
			context.WriteString(fmt.Sprintf("Available Items Here: %v\n", currentLoc.Items))
			context.WriteString(fmt.Sprintf("Available Exits: %v\n", currentLoc.Exits))
			
			if world.Location == npc.Location {
				context.WriteString("Player is also here\n")
				context.WriteString(fmt.Sprintf("Player Inventory: %v\n", world.Inventory))
			}
		}
	} else {
		currentLoc := world.Locations[world.Location]
		context.WriteString("Player Location: " + currentLoc.Title + " (" + world.Location + ")\n")
		context.WriteString(currentLoc.Description + "\n")
		context.WriteString(fmt.Sprintf("Player Inventory: %v\n", world.Inventory))
		context.WriteString(fmt.Sprintf("Available Items Here: %v\n", currentLoc.Items))
		context.WriteString(fmt.Sprintf("Available Exits: %v\n", currentLoc.Exits))
	}
	
	context.WriteString("\n")
	
	if len(gameHistory) > 0 {
		context.WriteString("RECENT CONVERSATION:\n")
		for _, exchange := range gameHistory {
			context.WriteString(exchange + "\n")
		}
		context.WriteString("\n")
	}
	
	return context.String()
}